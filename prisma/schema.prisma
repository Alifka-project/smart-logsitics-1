// Optimized Prisma Schema - Essential tables only

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Users table (drivers and admins)
model Driver {
  id        String   @id @default(uuid()) @db.Uuid
  username  String?  @unique @db.VarChar(100)
  email     String?  @db.VarChar(255)
  phone     String?  @db.VarChar(32)
  fullName  String?  @map("full_name") @db.VarChar(200)
  active    Boolean  @default(true)
  gpsEnabled Boolean @default(false) @map("gps_enabled") // GPS tracking enabled
  gpsPermissionGranted Boolean @default(false) @map("gps_permission_granted") // Browser permission granted
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  account           Account?
  status            DriverStatus?
  locations         LiveLocation[]
  assignments       DeliveryAssignment[]
  adminMessages     Message[] @relation("AdminMessages")
  driverMessages    Message[] @relation("DriverMessages")

  @@map("drivers")
}

// Account table for authentication (simplified - renamed from driver_accounts)
model Account {
  id              String    @id @default(uuid()) @db.Uuid
  driverId        String    @unique @map("driver_id") @db.Uuid
  passwordHash    String?   @map("password_hash") @db.Text
  lastLogin       DateTime? @map("last_login") @db.Timestamptz(6)
  role            String    @default("driver") @db.VarChar(50) // 'admin' or 'driver'
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)

  driver         Driver @relation(fields: [driverId], references: [id], onDelete: Cascade)
  passwordResets PasswordReset[]

  @@map("accounts")
}

// Driver status for tracking
model DriverStatus {
  driverId          String   @id @map("driver_id") @db.Uuid
  status            String   @db.VarChar(32) // 'available', 'busy', 'offline'
  updatedAt         DateTime @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)
  currentAssignmentId String? @map("current_assignment_id") @db.Uuid

  driver Driver @relation(fields: [driverId], references: [id])

  @@map("driver_status")
}

// Live GPS locations for drivers
model LiveLocation {
  id        BigInt   @id @default(autoincrement())
  driverId  String   @map("driver_id") @db.Uuid
  latitude  Float
  longitude Float
  heading   Float?
  speed     Float?
  accuracy  Float?
  recordedAt DateTime @default(now()) @map("recorded_at") @db.Timestamptz(6)

  driver Driver @relation(fields: [driverId], references: [id], onDelete: Cascade)

  @@index([driverId, recordedAt(sort: Desc)], map: "idx_live_locations_driver_time")
  @@index([recordedAt], map: "idx_live_locations_time")
  @@map("live_locations")
}

// Deliveries - stores full delivery data from uploads
model Delivery {
  id                        String   @id @default(uuid()) @db.Uuid
  customer                  String?   @db.VarChar(255)
  address                   String?   @db.Text
  phone                     String?   @db.VarChar(32)
  poNumber                  String?   @db.VarChar(100) // Purchase Order Number from uploaded file
  lat                       Float?
  lng                       Float?
  status                    String    @default("pending") @db.VarChar(50)
  items                     String?   @db.Text // JSON string or text description
  metadata                  Json?     // Additional metadata (original delivery number, PO, etc.)
  // New fields for SMS confirmation flow
  confirmationToken         String?   @unique @db.VarChar(255) // Token for SMS confirmation link
  confirmationStatus        String?   @default("pending") @db.VarChar(50) // pending, confirmed, expired
  customerConfirmedAt       DateTime? @map("customer_confirmed_at") @db.Timestamptz(6) // When customer confirmed
  availableDeliveryDates    Json?     @map("available_delivery_dates") // JSON array of available dates
  confirmedDeliveryDate     DateTime? @map("confirmed_delivery_date") @db.Timestamptz(6) // Date selected by customer
  tokenExpiresAt            DateTime? @map("token_expires_at") @db.Timestamptz(6) // Token expiration
  createdAt                 DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  updatedAt                 DateTime  @default(now()) @updatedAt @map("updated_at") @db.Timestamptz(6)

  assignments DeliveryAssignment[]
  events      DeliveryEvent[]
  smsConfirmations SmsConfirmation[]
  smsLogs     SmsLog[]

  @@index([status], map: "idx_delivery_status")
  @@index([createdAt], map: "idx_delivery_created")
  @@index([poNumber], map: "idx_delivery_po_number")
  @@index([confirmationToken], map: "idx_delivery_confirmation_token")
  @@index([confirmationStatus], map: "idx_delivery_confirmation_status")
  @@map("deliveries")
}

// Delivery assignments to drivers
model DeliveryAssignment {
  id        String    @id @default(uuid()) @db.Uuid
  deliveryId String   @map("delivery_id") @db.Uuid
  driverId    String  @map("driver_id") @db.Uuid
  assignedAt DateTime @default(now()) @map("assigned_at") @db.Timestamptz(6)
  status      String  @default("assigned") @db.VarChar(32)
  eta         DateTime? @db.Timestamptz(6)

  driver Driver @relation(fields: [driverId], references: [id])
  delivery Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  @@map("delivery_assignments")
}

// Delivery events for audit/logging
model DeliveryEvent {
  id        BigInt   @id @default(autoincrement())
  deliveryId String  @map("delivery_id") @db.Uuid
  eventType  String  @map("event_type") @db.VarChar(64)
  payload    Json?
  createdAt  DateTime @default(now()) @map("created_at") @db.Timestamptz(6)
  actorType  String?  @map("actor_type") @db.VarChar(32)
  actorId    String?  @map("actor_id") @db.Uuid

  delivery Delivery @relation(fields: [deliveryId], references: [id])

  @@map("delivery_events")
}

// SMS confirmations
model SmsConfirmation {
  id          BigInt    @id @default(autoincrement())
  deliveryId  String    @map("delivery_id") @db.Uuid
  phone       String?   @db.VarChar(32)
  provider    String?   @db.VarChar(50)
  messageId   String?   @map("message_id") @db.VarChar(128)
  status      String?   @db.VarChar(32)
  attempts    Int       @default(0)
  lastStatusAt DateTime? @map("last_status_at") @db.Timestamptz(6)
  createdAt   DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  metadata    Json?

  delivery Delivery @relation(fields: [deliveryId], references: [id])

  @@map("sms_confirmations")
}

// SMS Logs - Track all SMS communications
model SmsLog {
  id              BigInt    @id @default(autoincrement())
  deliveryId      String    @map("delivery_id") @db.Uuid
  phoneNumber     String    @map("phone_number") @db.VarChar(32)
  messageContent  String    @map("message_content") @db.Text
  smsProvider     String    @map("sms_provider") @db.VarChar(50) // twilio, aws-sns, mock, etc.
  externalMessageId String? @map("external_message_id") @db.VarChar(255) // ID from provider
  status          String    @default("pending") @db.VarChar(32) // pending, sent, failed, delivered
  failureReason   String?   @map("failure_reason") @db.Text
  sentAt          DateTime? @map("sent_at") @db.Timestamptz(6)
  deliveredAt     DateTime? @map("delivered_at") @db.Timestamptz(6)
  createdAt       DateTime  @default(now()) @map("created_at") @db.Timestamptz(6)
  metadata        Json?

  delivery Delivery @relation(fields: [deliveryId], references: [id], onDelete: Cascade)

  @@index([deliveryId], map: "idx_sms_log_delivery")
  @@index([phoneNumber], map: "idx_sms_log_phone")
  @@index([status], map: "idx_sms_log_status")
  @@index([createdAt], map: "idx_sms_log_created")
  @@map("sms_logs")
}

// Chat messages between admin and drivers
model Message {
  id        String   @id @default(uuid()) @db.Uuid
  adminId   String   @map("admin_id") @db.Uuid
  driverId  String   @map("driver_id") @db.Uuid
  content   String   @db.Text
  isRead    Boolean  @default(false) @map("is_read")
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  admin   Driver @relation("AdminMessages", fields: [adminId], references: [id], onDelete: Cascade)
  driver  Driver @relation("DriverMessages", fields: [driverId], references: [id], onDelete: Cascade)

  @@index([adminId, driverId, createdAt(sort: Desc)], map: "idx_messages_conversation")
  @@index([driverId], map: "idx_messages_driver")
  @@index([createdAt], map: "idx_messages_created")
  @@map("messages")
}

// Password reset tokens
model PasswordReset {
  id        String   @id @default(uuid()) @db.Uuid
  accountId String   @map("account_id") @db.Uuid
  token     String   @unique @db.VarChar(255)
  expiresAt DateTime @map("expires_at") @db.Timestamptz(6)
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at") @db.Timestamptz(6)

  account Account @relation(fields: [accountId], references: [id], onDelete: Cascade)

  @@index([token], map: "idx_password_reset_token")
  @@index([expiresAt], map: "idx_password_reset_expires")
  @@map("password_resets")
}
